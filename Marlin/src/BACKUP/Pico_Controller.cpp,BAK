#include "MarlinCore.h"
#include "sd\cardreader.h"
#include "module\stepper.h"
#include "module\temperature.h"
#include "module\configuration_store.h"
#include "gcode\gcode.h"
#include "gcode\queue.h"
#include "feature\pause.h"
#include "core\utility.h"
#include "Pico_Controller.h"

uint16_t blink_time = 0;
uint16_t blinkfeed_time = 0;
uint16_t blinkretract_time = 0;

uint8_t print_key_flag = 0;
float z_height_stop = 0;
float temperature_protect_last = 0;

volatile uint32_t protect_time = 0;

uint8_t print_pause = 0;  

uint32_t sys_time = 0;

uint8_t cancel_print = 0;

uint8_t key_flag = 0; 

void BlinkLed(void) {
  static uint32_t blink_time_previous = 0;
  static uint32_t blink_time_start = 0;
  if (blink_time == 0) {
    WRITE(PRINT_LED, HIGH);
    return;
  }
  if (blink_time > 3000) {
    WRITE(PRINT_LED, LOW);
    return;
  }
  if (blink_time_previous != blink_time) {
    blink_time_previous = blink_time;
    blink_time_start = millis();
  }
  if (millis() < blink_time_start + blink_time) {
    WRITE(PRINT_LED, 0);
  } else if (millis() < blink_time_start + 2 * blink_time) {
    WRITE(PRINT_LED, 1);
  } else {
    blink_time_start = millis();
  }
}

void BlinkFeedLed(void) {
  static uint32_t blink_time_previous = 0;
  static uint32_t blink_time_start = 0;
  if (blinkfeed_time == 0) {
    // WRITE(FEED_LED, 1);
    return;
  }
  if (blinkfeed_time > 3000) {
    // WRITE(FEED_LED, 0);
    return;
  }
  if (blink_time_previous != blinkfeed_time) {
    blink_time_previous = blinkfeed_time;
    blink_time_start = millis();
  }
  if (millis() < blink_time_start + blinkfeed_time) {
    WRITE(FEED_LED, 0);
  } else if (millis() < blink_time_start + 2 * blinkfeed_time) {
    WRITE(FEED_LED, 1);
  } else {
    blink_time_start = millis();
  }
}
void BlinkRetractLed(void) {
  static uint32_t blink_time_previous = 0;
  static uint32_t blink_time_start = 0;
  if (blinkretract_time == 0) {
    WRITE(RETRACT_LED, 1);
    return;
  }
  if (blinkretract_time > 3000) {
    WRITE(RETRACT_LED, 0);
    return;
  }
  if (blink_time_previous != blinkretract_time) {
    blink_time_previous = blinkretract_time;
    blink_time_start = millis();
  }
  if (millis() < blink_time_start + blinkretract_time) {
    WRITE(RETRACT_LED, 0);
  } else if (millis() < blink_time_start + 2 * blinkretract_time) {
    WRITE(RETRACT_LED, 1);
  } else {
    blink_time_start = millis();
  }
}

void SendColors(byte red, byte grn, byte blu) {
  Wire.begin();
  Wire.beginTransmission(0x09);
  Wire.write('o');  
  Wire.write('n');
  Wire.write(red);
  Wire.write(grn);
  Wire.write(blu);
  Wire.endTransmission();
}


void PrintOneKey(void) {
  static uint8_t key_status = 0;
  static uint32_t key_time = 0;
  static uint8_t pause_flag = 0;

  if (key_flag == 1 || key_flag == 2 || key_flag == 3) return;

  if (key_status == 0) 
  {
    if (!READ(PRINT_START_PIN)) {
      key_time = millis();
      key_status = 1;
    }
  } else if (key_status == 1) 
  {
    if (key_time + 30 < millis()) {
      if (!READ(PRINT_START_PIN)) {
        key_time = millis();
        key_status = 2;
      } else {
        key_status = 0;
      }
    }
  } else if (key_status == 2) 
  {
    if (READ(PRINT_START_PIN)) 
    {
      if (key_time + 1000 > millis()) 
      {
        if (print_key_flag == 0) 
        {
          card.mount();
          if (card.isMounted()) {
            BLINK_LED(LED_OFF);
            key_status = 0;
            key_time = 0;
            return;
          }
          uint16_t filecnt = card.get_num_Files();
          card.getfilename_sorted(filecnt);
          while (card.countFilesInWorkDir) {
            if (filecnt > 1) {
              filecnt--;
              card.getfilename_sorted(filecnt);
            }
          }
          card.openFileRead(card.filename, true);
          card.startFileprint();
          BLINK_LED(LED_BLINK_0);
          print_key_flag = 1;
          key_flag = 4;
        } else if (print_key_flag == 1) 
        {
          // MYSERIAL.print("pause");
          BLINK_LED(LED_ON);
          card.pauseSDPrint();
          print_pause = 1;
          print_key_flag = 2;
        } else if (print_key_flag == 2) 
        {
          // MYSERIAL.print("print");
          if (temperature_protect_last > 60) {
            gcode.process_subcommands_now("M109 F");;
            temperature_protect_last = 0;
          }
          BLINK_LED(LED_BLINK_0);
          card.startFileprint();
          print_pause = 0;
          print_key_flag = 1;
        } else {
          print_key_flag = 0;
        }

      } else  
      {
        if (print_key_flag == 0)  
        {
          if (IsRunning()) {
            destination[Z_AXIS] += 10;
            feedrate_mm_s = (10 * 60);
            enable_all_steppers();
          }
        } else 
        {
          z_height_stop = stepper.position(Z_AXIS);
          // MYSERIAL.print("cancel");

          card.closefile();
          cancel_heatup = true;
          //cancel_gohome_ms = millis() + 500;

          quickstop_stepper(); 
          card.closefile();
          ;  // switch off all heaters.

          cancel_print = 1;
          key_flag = 0;
          BLINK_LED(LED_OFF);
          print_key_flag = 0;
          print_pause = 0;
        }
      }
      key_status = 0;
      key_time = 0;
    }
  } else {
    key_status = 0;
    key_time = 0;
    print_key_flag = 0;
  }
}


void feed_filament(void) {
  if (IsRunning()) {
    //    MYSERIAL.print("Feeding Filament");
    destination[E_AXIS] += 100;
    feedrate_mm_s = 1.5 * 60;
    enable_all_steppers();
  }
}

void retract_filament(void) {
  if (IsRunning()) {
    //	MYSERIAL.print("Retract Filament");
    destination[E_AXIS] += 2;
    feedrate_mm_s = 3 * 60;
    enable_all_steppers();

    destination[E_AXIS] -= 300;
    feedrate_mm_s = 15.0 * 60;
    enable_all_steppers();
  }
}


void LoadFilament(void) {
  static uint8_t filament_status = 0;
  static uint8_t filament_flag = 0;  
  static uint8_t key = 0;
  static uint32_t key_time = 0;

  if (key_flag == 1 || key_flag == 4) return;

  if (filament_status == 0)
  {
    if (!READ(RETRACT_PIN)) {
      key = 0x01;
    };
    if (!READ(FEED_PIN)) {
      key = 0x02;
    };
    if (key) {
      filament_status++;
      key_time = millis() + 20;
    }
  } else if (filament_status == 1)
  {
    if (key_time <= millis()) {
      if (READ(RETRACT_PIN)) {
        key &= ~0x01;
      }
      if (READ(FEED_PIN)) {
        key &= ~0x02;
      }
      if (key) {
        protect_time = millis();
        hotend_watch_t();
        if (key & 0x01) {
          BLINKRETRACT_LED(LED_BLINK_7);
          BLINKFEED_LED(LED_OFF);
          key_flag = 2;
        }
        if (key & 0x02) {
          BLINKFEED_LED(LED_BLINK_7);
          BLINKRETRACT_LED(LED_OFF);
          key_flag = 3;
        }
        filament_status++;
      } else {
        key_flag = 0;
        filament_status = 0;
      }
    }
  } else if (filament_status == 2) 
  {
    if (READ(RETRACT_PIN) && READ(FEED_PIN)) {
      filament_status = 3;
    }
  } else if (filament_status == 3)  
  {
    if (HOTEND_TEMPS >= 210)  
    {
      filament_status++;
    } else  
    {
      if (!READ(RETRACT_PIN))  
      {
        if (key == 0x01)  
        {
          key = 0;
          key_flag = 0;
          filament_status = 6;
          gcode.process_subcommands_now("M109 R0");
          //	MYSERIAL.print("retract_hot0_cancel");
        } else {
          key = 0x01;
          BLINKRETRACT_LED(LED_BLINK_7);
          BLINKFEED_LED(LED_OFF);
          key_flag = 2;
          //	MYSERIAL.print("retract_hot0");
          filament_status = 2;
        }
      };
      if (!READ(FEED_PIN)) 
      {
        if (key == 0x02) 
        {
          key = 0;
          key_flag = 0;
          filament_status = 6;
          gcode.process_subcommands_now("M109 R0");
          //	MYSERIAL.print("feed_hot0_cancel");
        } else {
          key = 0x02;
          BLINKFEED_LED(LED_BLINK_7);
          BLINKRETRACT_LED(LED_OFF);
          key_flag = 3;
          // MYSERIAL.print("feed_hot0");
          filament_status = 2;
        }
      };
    }
  } else if (filament_status == 4)
  {
    if (key & 0x01) {
      retract_filament();
      BLINKRETRACT_LED(LED_BLINK_5);
      BLINKFEED_LED(LED_OFF);
    };  
    if (key & 0x02) {
      feed_filament();
      BLINKFEED_LED(LED_BLINK_5);
      BLINKRETRACT_LED(LED_OFF);
    };  
    filament_status++;
  } else if (filament_status == 5) 
  {
    if (!queue.has_commands_queued()) 
    {
      BLINKRETRACT_LED(LED_OFF);
      BLINKFEED_LED(LED_OFF);
      filament_status = 0;
      key_flag = 0;
      key = 0;
    }

    if (!READ(RETRACT_PIN)) {
      if (key == 0x01) 
      {
        queue.clear();
        BLINKRETRACT_LED(LED_OFF);
        filament_status = 6;
        key_flag = 0;
      } else {
        queue.clear();
        key = 0x01;
        key_flag = 2;
        filament_status = 7;
      }
    }
    if (!READ(FEED_PIN)) {
      if (key == 0x02) {
        queue.clear();
        BLINKFEED_LED(LED_OFF);
        key_flag = 0;
        filament_status = 6;
      } else {
        queue.clear();
        key = 0x02;
        key_flag = 3;
        filament_status = 7;
      }
    }
  } else if (filament_status == 8)  
  {
    if (READ(RETRACT_PIN) && READ(FEED_PIN)) 
    {
      filament_status = 3;
    }
  } else if (filament_status == 7) 
  {
    if (READ(RETRACT_PIN) && READ(FEED_PIN)) 
    {
      filament_status = 4;
    }
  } else if (filament_status == 6) 
  {
    if (READ(RETRACT_PIN) && READ(FEED_PIN))  
    {
      BLINKRETRACT_LED(LED_OFF);
      BLINKFEED_LED(LED_OFF);
      filament_status = 0;
    }
  } else {
    filament_status = 0;
  }
}

void home_key(void) {
  static uint8_t key_status = 0;
  static uint32_t key_time;

  if (key_flag == 4 || key_flag == 2 || key_flag == 3) return;

  if (key_status == 0) {
    if (!READ(Z_HOME_PIN)) {
      key_time = millis() + 50;
      key_status = 1;
    }
  } else if (key_status == 1) {
    if (key_time <= millis()) {
      if (!READ(Z_HOME_PIN)) {
        key_status = 2;
      } else {
        key_status = 0;
      }
    }
  } else if (key_status == 2) {
    WRITE(HOME_LED, 0);
    enable_all_steppers();
    gcode.process_subcommands_now("G28");
    key_flag = 1;
    key_status = 4;
  } else if (key_status == 4)  
  {
    if (READ(Z_HOME_PIN)) {
      key_status = 3;
    }
  } else if (key_status == 3)  
  {
    if (!queue.has_commands_queued()) {
      key_status = 0;
      WRITE(HOME_LED, 1);
      key_flag = 0;
    }
  }
}

//void heat_protect(void) {
//  if (current_temperature[0] < 60) return;
//  if (card.isPrinting == true) return;
//  if (blocks_queued()) return;
//  if (commands_in_queue) return;
//  if (key_flag != 0) return;

//  if (card.isPrinting == false)
//  {
//    if (protect_time + 600000l < millis()) {
//      protect_time = millis();
//      temperature_protect_last = Temperature;
//      disable_all_steppers();
//      //MYSERIAL.print("extruder heating off!");
//    }
//  }
//}
